name: Deploy Fullstack App to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual trigger

jobs:
  # ============================
  # ðŸ—ï¸ BUILD STAGE
  # ============================
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      frontend-build: ${{ steps.build-frontend.outputs.cache-key }}
      backend-build: ${{ steps.build-backend.outputs.cache-key }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js with enhanced caching
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        id: cache-deps
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: npm ci --legacy-peer-deps
        env:
          CI: true

      # Build frontend and backend in parallel using matrix strategy
      - name: Build frontend
        id: build-frontend
        run: |
          echo "ðŸ”· Building React app..."

          # Load .env file if exists, or use secrets/environment
          if [ -f ".env" ]; then
            echo "ðŸ“„ Loading REACT_APP_API_URL from .env file..."
            export REACT_APP_API_URL=$(grep "^REACT_APP_API_URL=" .env | cut -d'=' -f2- | sed 's/^"//;s/"$//' | tr -d '\r\n' || echo "")
            echo "âœ… Loaded from .env: REACT_APP_API_URL=$REACT_APP_API_URL"
          fi

          # Fallback to GitHub Secrets or default
          if [ -z "$REACT_APP_API_URL" ]; then
            REACT_APP_API_URL="${{ secrets.REACT_APP_API_URL }}"
            if [ -z "$REACT_APP_API_URL" ]; then
              REACT_APP_API_URL="https://rickychen930.cloud"
            fi
            export REACT_APP_API_URL
            echo "âœ… Using fallback: REACT_APP_API_URL=$REACT_APP_API_URL"
          fi

          # Verify the value
          echo "ðŸ” Final REACT_APP_API_URL=$REACT_APP_API_URL"

          # Build with the environment variable
          REACT_APP_API_URL="$REACT_APP_API_URL" npm run build

          if [ ! -d "build" ] || [ -z "$(ls -A build)" ]; then
            echo "âŒ Frontend build failed or is empty"
            exit 1
          fi

          # Verify REACT_APP_API_URL is embedded in build (check for the URL in JS files)
          if grep -r "rickychen930.cloud" build/static/js/*.js > /dev/null 2>&1; then
            echo "âœ… Verified: API URL is embedded in build"
          else
            echo "âš ï¸  Warning: API URL might not be embedded in build"
          fi

          echo "âœ… Frontend build verified ($(du -sh build | cut -f1))"
          echo "cache-key=frontend-${{ github.sha }}" >> $GITHUB_OUTPUT
        env:
          # This will be overridden by .env file or script logic above
          REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL || 'https://rickychen930.cloud' }}

      - name: Build backend
        id: build-backend
        run: |
          echo "ðŸ”¶ Building backend..."
          npm run backend:build
          if [ ! -d "backend/dist" ] || [ ! -f "backend/dist/main.js" ]; then
            echo "âŒ Backend build failed"
            exit 1
          fi
          echo "âœ… Backend build verified ($(du -sh backend/dist | cut -f1))"
          echo "cache-key=backend-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Prepare deployment artifacts
        run: |
          echo "ðŸ“¦ Creating deployment packages..."
          # Create compressed backend package
          tar -czf backend-deploy.tar.gz \
            backend/dist \
            backend/ecosystem.config.js \
            package.json \
            package-lock.json \
            scripts/fix-backend-on-server.sh \
            scripts/fix-mongodb-uri.sh \
            scripts/fix-mongodb-uri-simple.js \
            .env 2>/dev/null || true

          # Create compressed frontend package
          tar -czf frontend-deploy.tar.gz build

          # Create nginx config package
          tar -czf nginx-deploy.tar.gz config/nginx.conf 2>/dev/null || true

          echo "âœ… Artifacts created"
          ls -lh *.tar.gz

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts
          path: |
            backend-deploy.tar.gz
            frontend-deploy.tar.gz
            nginx-deploy.tar.gz
          retention-days: 1

  # ============================
  # ðŸš€ DEPLOY STAGE
  # ============================
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    needs: build

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts

      - name: Validate deployment secrets
        run: |
          if [ -z "${{ secrets.HOSTINGER_HOST }}" ]; then
            echo "âŒ Error: HOSTINGER_HOST secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.HOSTINGER_USER }}" ]; then
            echo "âŒ Error: HOSTINGER_USER secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.HOSTINGER_SSH_KEY }}" ]; then
            echo "âŒ Error: HOSTINGER_SSH_KEY secret is not set"
            exit 1
          fi

          HOST="${{ secrets.HOSTINGER_HOST }}"

          # Validate that HOST is an IP address, not a hostname
          if [[ ! "$HOST" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "âŒ ERROR: HOSTINGER_HOST appears to be a hostname, not an IP address!"
            echo ""
            echo "Current value format: $HOST"
            echo ""
            echo "ðŸ”§ SOLUTION:"
            echo "1. Go to: Repository â†’ Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Edit 'HOSTINGER_HOST' secret"
            echo "3. Replace hostname with IP address (e.g., '185.123.45.67')"
            echo "4. Save and re-run this workflow"
            echo ""
            echo "ðŸ’¡ Why IP address?"
            echo "   GitHub Actions runners cannot resolve some hostnames."
            echo "   Using IP address directly avoids DNS resolution issues."
            echo ""
            echo "ðŸ“ To find your VPS IP address:"
            echo "   - Check Hostinger control panel â†’ VPS details"
            echo "   - Or run: nslookup your-hostname.com (from your local machine)"
            exit 1
          fi

          echo "âœ… All deployment secrets are configured"
          echo "Host: $HOST (IP address format validated)"
          echo "User: ${{ secrets.HOSTINGER_USER }}"
          echo "Port: 22"

          # Test connectivity to IP address
          echo "ðŸ” Testing connectivity to IP address..."
          echo "âš ï¸  IMPORTANT: Make sure IP address is correct!"
          echo "   Expected: 72.60.208.150 (for ricky.website)"
          echo "   Current: $HOST"
          if [ "$HOST" != "72.60.208.150" ]; then
            echo "âš ï¸  WARNING: IP address doesn't match expected value!"
            echo "   Please verify the correct IP address in Hostinger control panel"
          fi

          if command -v nc &> /dev/null; then
            echo "Testing port 22 connectivity (10 second timeout)..."
            if timeout 10 nc -zv "$HOST" 22 2>&1; then
              echo "âœ… Port 22 is reachable"
            else
              echo "âŒ Port 22 connection test FAILED"
              echo ""
              echo "ðŸ”§ TROUBLESHOOTING:"
              echo "1. Verify IP address is correct: $HOST"
              echo "2. Check if VPS is running (ping from local machine)"
              echo "3. Check firewall allows port 22 from GitHub Actions IPs"
              echo "4. Verify SSH service is running on VPS"
              echo ""
              echo "ðŸ’¡ Test from your local machine:"
              echo "   ssh -v root@$HOST"
              exit 1
            fi
          else
            echo "âš ï¸  nc (netcat) not available, skipping connectivity test"
          fi

      - name: Test SSH connection (with retry)
        uses: appleboy/ssh-action@v1.0.3
        continue-on-error: false
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          timeout: 120s
          command_timeout: 120s
          script: |
            echo "âœ… SSH connection successful"
            echo "Hostname: $(hostname)"
            echo "Uptime: $(uptime)"
            echo "Disk space:"
            df -h / | tail -1
            echo ""
            echo "Network info:"
            ip addr show | grep "inet " | head -3

      - name: Deploy to VPS (Backend + Frontend + Config)
        id: scp-deploy
        uses: appleboy/scp-action@v0.1.7
        continue-on-error: false
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          source: "*.tar.gz"
          target: "/tmp/deploy"
          strip_components: 0
          timeout: 120s
          command_timeout: 120s
          debug: true
          overwrite: true
        env:
          # Increase timeout for slow connections
          SCP_TIMEOUT: 120

      - name: Extract and deploy all services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "ðŸ“¦ Extracting deployment packages..."

            # Create directories
            mkdir -p /root/backend/{logs,dist} /var/www/website-ts /tmp/deploy
            cd /tmp/deploy

            # Extract backend
            if [ -f "backend-deploy.tar.gz" ]; then
              echo "ðŸ”¶ Extracting backend..."
              tar -xzf backend-deploy.tar.gz -C /root/backend --strip-components=2 2>/dev/null || \
              tar -xzf backend-deploy.tar.gz -C /root/backend 2>/dev/null || true
              
              # Move files to correct locations
              [ -d "/tmp/deploy/backend/dist" ] && cp -r /tmp/deploy/backend/dist/* /root/backend/dist/ 2>/dev/null || true
              [ -f "/tmp/deploy/backend/ecosystem.config.js" ] && cp /tmp/deploy/backend/ecosystem.config.js /root/backend/ 2>/dev/null || true
              [ -f "/tmp/deploy/package.json" ] && cp /tmp/deploy/package.json /root/backend/ 2>/dev/null || true
              [ -f "/tmp/deploy/package-lock.json" ] && cp /tmp/deploy/package-lock.json /root/backend/ 2>/dev/null || true
              [ -f "/tmp/deploy/scripts/fix-backend-on-server.sh" ] && \
                cp /tmp/deploy/scripts/fix-backend-on-server.sh /root/backend/ 2>/dev/null || \
                [ -f "/tmp/deploy/fix-backend-on-server.sh" ] && \
                cp /tmp/deploy/fix-backend-on-server.sh /root/backend/ 2>/dev/null || true
              
              # Keep .env in temp for update step (if exists in deployment)
              [ -f "/tmp/deploy/.env" ] && cp /tmp/deploy/.env /tmp/deploy/.env.new 2>/dev/null || true
            fi

            # Extract frontend
            if [ -f "frontend-deploy.tar.gz" ]; then
              echo "ðŸ”· Extracting frontend..."
              rm -rf /var/www/website-ts/build
              mkdir -p /var/www/website-ts
              tar -xzf frontend-deploy.tar.gz -C /var/www/website-ts
              sudo chown -R www-data:www-data /var/www/website-ts
              sudo chmod -R 755 /var/www/website-ts
            fi

            # Extract nginx config
            if [ -f "nginx-deploy.tar.gz" ]; then
              echo "âš™ï¸  Extracting nginx config..."
              tar -xzf nginx-deploy.tar.gz -C /tmp
              if [ -f "/tmp/config/nginx.conf" ] || [ -f "/tmp/nginx.conf" ]; then
                NGINX_CONF=$(find /tmp -name "nginx.conf" -type f | head -1)
                if [ -n "$NGINX_CONF" ]; then
                  sudo cp "$NGINX_CONF" /etc/nginx/sites-available/rickychen930.cloud 2>/dev/null || true
                fi
              fi
            fi

            echo "âœ… Extraction complete"

      - name: Update .env file (effective method)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "ðŸ” Updating .env file..."
            cd /root/backend
            ENV_FILE="/root/backend/.env"
            ENV_BACKUP="/root/backend/.env.backup.$(date +%Y%m%d_%H%M%S)"
            ENV_NEW="/tmp/deploy/.env.new"

            # Backup existing .env
            if [ -f "$ENV_FILE" ]; then
              cp "$ENV_FILE" "$ENV_BACKUP"
              echo "âœ… Backup created: $(basename $ENV_BACKUP)"
            fi

            # Start with existing .env or create new
            if [ -f "$ENV_FILE" ]; then
              cp "$ENV_FILE" "$ENV_FILE.tmp"
            else
              touch "$ENV_FILE.tmp"
            fi

            # Update/Add from deployment .env file
            if [ -f "$ENV_NEW" ]; then
              echo "ðŸ“ Applying changes from deployment .env..."
              while IFS= read -r line || [ -n "$line" ]; do
                line=$(echo "$line" | xargs)
                [[ -z "$line" || "$line" =~ ^# ]] && continue
                
                key=$(echo "$line" | cut -d'=' -f1 | xargs)
                value=$(echo "$line" | cut -d'=' -f2- | xargs | sed 's/^"//;s/"$//')
                [[ -z "$key" ]] && continue
                
                if grep -q "^${key}=" "$ENV_FILE.tmp" 2>/dev/null; then
                  sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE.tmp" 2>/dev/null || true
                else
                  echo "${key}=${value}" >> "$ENV_FILE.tmp"
                fi
              done < "$ENV_NEW"
            fi

            # Create reusable Node.js script for cleaning MONGODB_URI
            cat > /tmp/clean-mongodb-uri.js << 'HEREDOC_END'
function cleanMongoDBUri(uri) {
  if (!uri || typeof uri !== 'string') return uri;
  if (!uri.includes('?')) {
    return uri + '?retryWrites=true&w=majority';
  }
  const parts = uri.split('?', 2);
  const base = parts[0];
  const query = parts[1];
  const params = query.split('&').filter(function(p) { return p.trim(); });
  const seen = {};
  const cleaned = [];
  for (var i = 0; i < params.length; i++) {
    var param = params[i];
    if (!param) continue;
    var key = param.split('=')[0];
    if (!seen[key]) {
      seen[key] = true;
      cleaned.push(param);
    }
  }
  if (!seen['retryWrites']) cleaned.push('retryWrites=true');
  if (!seen['w']) cleaned.push('w=majority');
  return base + '?' + cleaned.join('&');
}
if (typeof module !== 'undefined' && module.exports) {
  module.exports = cleanMongoDBUri;
}
if (require.main === module) {
  var uri = process.argv[2];
  if (!uri) {
    console.error('Usage: node clean-mongodb-uri.js <uri>');
    process.exit(1);
  }
  console.log(cleanMongoDBUri(uri));
}
HEREDOC_END

            # Fast update from GitHub Secrets (priority over file)
            echo "ðŸ”‘ Updating from GitHub Secrets..."
            {
              # Helper function to set env var (handles special characters)
              set_env() {
                local key="$1"
                local value="$2"
                if [ -n "$value" ]; then
                  if grep -q "^${key}=" "$ENV_FILE.tmp" 2>/dev/null; then
                    sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE.tmp" 2>/dev/null || true
                  else
                    echo "${key}=${value}" >> "$ENV_FILE.tmp"
                  fi
                  echo "  âœ“ $key (updated)"
                else
                  echo "  âš  $key (not set in secrets)"
                fi
              }
              
              # Update from secrets (only if provided)
              set_env "PORT" "${{ secrets.BACKEND_PORT }}"
              set_env "NODE_ENV" "${{ secrets.NODE_ENV }}"
              
              # MONGODB_URI requires special handling - use Node.js script
              MONGODB_URI_VALUE="${{ secrets.MONGODB_URI }}"
              if [ -n "$MONGODB_URI_VALUE" ]; then
                # Clean MONGODB_URI using Node.js script
                MONGODB_URI_VALUE=$(node /tmp/clean-mongodb-uri.js "$MONGODB_URI_VALUE")
                
                # Validate format
                if [[ "$MONGODB_URI_VALUE" =~ ^mongodb(\+srv)?:// ]]; then
                  echo "  âœ… MONGODB_URI cleaned and validated"
                else
                  echo "  âš ï¸  WARNING: MONGODB_URI format might be incorrect"
                fi
                
                set_env "MONGODB_URI" "$MONGODB_URI_VALUE"
              else
                echo "  âŒ ERROR: MONGODB_URI secret is not set!"
                echo "     Please set MONGODB_URI in GitHub Secrets"
                exit 1
              fi
              
              set_env "ALLOWED_ORIGINS" "${{ secrets.ALLOWED_ORIGINS }}"
              set_env "SSL_CERT_PATH" "${{ secrets.SSL_CERT_PATH }}"
              set_env "SSL_KEY_PATH" "${{ secrets.SSL_KEY_PATH }}"
            }

            # Verify MONGODB_URI was set correctly (without showing the actual value)
            if grep -q "^MONGODB_URI=" "$ENV_FILE.tmp" 2>/dev/null; then
              MONGODB_URI_LINE=$(grep "^MONGODB_URI=" "$ENV_FILE.tmp")
              MONGODB_URI_LENGTH=${#MONGODB_URI_LINE}
              if [ "$MONGODB_URI_LENGTH" -lt 20 ]; then
                echo "âš ï¸  WARNING: MONGODB_URI seems too short (might be incomplete)"
              else
                echo "âœ… MONGODB_URI is set (length: ${MONGODB_URI_LENGTH} chars)"
              fi
            else
              echo "âŒ ERROR: MONGODB_URI not found in .env file after update!"
              exit 1
            fi

            # Ensure defaults exist
            if ! grep -q "^PORT=" "$ENV_FILE.tmp" 2>/dev/null; then
              echo "PORT=4000" >> "$ENV_FILE.tmp"
            fi
            if ! grep -q "^NODE_ENV=" "$ENV_FILE.tmp" 2>/dev/null; then
              echo "NODE_ENV=production" >> "$ENV_FILE.tmp"
            fi

            # Finalize
            mv "$ENV_FILE.tmp" "$ENV_FILE"
            chmod 600 "$ENV_FILE"

            echo "âœ… .env updated"
            echo "ðŸ“Š Variables: $(grep -v '^#' "$ENV_FILE" | grep -c '=' || echo 0)"

            # Final check: Ensure MONGODB_URI is clean (using reusable script)
            echo ""
            echo "ðŸ”§ Final check: Verifying MONGODB_URI..."
            if grep -q "^MONGODB_URI=" "$ENV_FILE" 2>/dev/null; then
              MONGODB_URI_VALUE=$(grep "^MONGODB_URI=" "$ENV_FILE" | cut -d'=' -f2-)
              CLEANED_URI=$(node /tmp/clean-mongodb-uri.js "$MONGODB_URI_VALUE")
              
              if [ "$CLEANED_URI" != "$MONGODB_URI_VALUE" ]; then
                sed -i "s|^MONGODB_URI=.*|MONGODB_URI=${CLEANED_URI}|" "$ENV_FILE"
                echo "âœ… MONGODB_URI cleaned"
              else
                echo "âœ… MONGODB_URI is already clean"
              fi
              
              # Validate format
              if [[ "$CLEANED_URI" =~ ^mongodb(\+srv)?:// ]]; then
                echo "âœ… MONGODB_URI format validated"
              else
                echo "âŒ ERROR: MONGODB_URI format is incorrect!"
                exit 1
              fi
            else
              echo "âŒ ERROR: MONGODB_URI not found in .env file!"
              exit 1
            fi

            if grep -q "^NODE_ENV=" "$ENV_FILE" 2>/dev/null; then
              echo "âœ… NODE_ENV is set"
            else
              echo "âš ï¸  NODE_ENV not set (will use default)"
            fi

            if grep -q "^PORT=" "$ENV_FILE" 2>/dev/null; then
              echo "âœ… PORT is set"
            else
              echo "âš ï¸  PORT not set (will use default 4000)"
            fi

            # Cleanup: remove temp scripts and old backups
            rm -f /tmp/clean-mongodb-uri.js
            ls -t "$(dirname $ENV_FILE)"/.env.backup.* 2>/dev/null | tail -n +4 | xargs rm -f 2>/dev/null || true

      - name: Install dependencies and restart services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "âš™ï¸  Configuring services..."
            cd /root/backend

            # Install production dependencies
            echo "ðŸ“¦ Installing production dependencies..."
            npm ci --omit=dev --ignore-scripts --legacy-peer-deps 2>/dev/null || \
            npm install --omit=dev --ignore-scripts --legacy-peer-deps || true

            # Verify PM2 config
            if [ ! -f "ecosystem.config.js" ]; then
              echo "âŒ PM2 ecosystem.config.js not found"
              exit 1
            fi

            # Make fix script executable
            [ -f "fix-backend-on-server.sh" ] && chmod +x fix-backend-on-server.sh || true

            # Restart backend
            echo "ðŸ”„ Restarting backend..."
            if [ -f "fix-backend-on-server.sh" ]; then
              ./fix-backend-on-server.sh || {
                echo "âš ï¸  Fix script failed, using manual restart..."
                pm2 stop website-backend 2>/dev/null || true
                pm2 delete website-backend 2>/dev/null || true
                pm2 start ecosystem.config.js --env production
                pm2 save
              }
            else
              pm2 stop website-backend 2>/dev/null || true
              pm2 delete website-backend 2>/dev/null || true
              pm2 start ecosystem.config.js --env production
              pm2 save
            fi

            # Wait a bit for process to start
            echo "â³ Waiting for backend to start (5 seconds)..."
            sleep 5

            # Final verification before restart (quick check)
            echo "ðŸ”§ Final verification: Checking MONGODB_URI..."
            if [ -f "/root/backend/.env" ] && grep -q "^MONGODB_URI=" /root/backend/.env 2>/dev/null; then
              MONGODB_URI_VALUE=$(grep "^MONGODB_URI=" /root/backend/.env | cut -d'=' -f2-)
              CLEANED_URI=$(node /tmp/clean-mongodb-uri.js "$MONGODB_URI_VALUE")
              
              if [ "$CLEANED_URI" != "$MONGODB_URI_VALUE" ]; then
                sed -i "s|^MONGODB_URI=.*|MONGODB_URI=${CLEANED_URI}|" /root/backend/.env
                echo "âœ… Fixed MONGODB_URI duplicates"
              else
                echo "âœ… MONGODB_URI is clean"
              fi
            fi

            # Verify PM2 process is running
            echo "ðŸ” Verifying PM2 process status..."
            pm2 list

            # Check PM2 status (without jq dependency)
            PM2_LIST=$(pm2 list 2>/dev/null)
            if echo "$PM2_LIST" | grep -q "website-backend.*online"; then
              echo "âœ… PM2 process is online"
            elif echo "$PM2_LIST" | grep -q "website-backend"; then
              PM2_STATUS=$(echo "$PM2_LIST" | grep "website-backend" | awk '{print $10}' || echo "unknown")
              echo "âŒ ERROR: PM2 process is not online! Status: $PM2_STATUS"
              echo "ðŸ“‹ PM2 Info:"
              pm2 info website-backend 2>/dev/null || echo "Could not get PM2 info"
              echo "ðŸ“‹ PM2 Logs (last 50 lines):"
              pm2 logs website-backend --lines 50 --nostream 2>/dev/null || true
              exit 1
            else
              echo "âŒ ERROR: PM2 process 'website-backend' not found!"
              echo "ðŸ“‹ PM2 List:"
              pm2 list
              exit 1
            fi

            # Check if port is listening
            echo "ðŸ” Checking if port 4000 is listening..."
            if command -v netstat &> /dev/null; then
              netstat -tlnp | grep :4000 || echo "âš ï¸  Port 4000 not found in netstat"
            fi
            if command -v ss &> /dev/null; then
              ss -tlnp | grep :4000 || echo "âš ï¸  Port 4000 not found in ss"
            fi

            # Restart nginx
            echo "ðŸ”„ Restarting nginx..."
            sudo nginx -t 2>/dev/null && sudo systemctl reload nginx 2>/dev/null || \
            sudo systemctl restart nginx 2>/dev/null || true

            echo "âœ… Services restarted"

            # Cleanup deployment temp files
            rm -rf /tmp/deploy

      - name: Verify backend status before health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set +e

            echo "ðŸ” Pre-health check verification..."

            # Check PM2 status
            echo "ðŸ“‹ PM2 Status:"
            pm2 list

            # Check if process exists and is online (without jq)
            PM2_LIST=$(pm2 list 2>/dev/null)
            if echo "$PM2_LIST" | grep -q "website-backend.*online"; then
              echo "âœ… PM2 process is online"
            elif echo "$PM2_LIST" | grep -q "website-backend"; then
              PM2_STATUS=$(echo "$PM2_LIST" | grep "website-backend" | awk '{print $10}' || echo "unknown")
              echo "âŒ PM2 process is not online! Status: $PM2_STATUS"
              echo "ðŸ“‹ PM2 Info:"
              pm2 info website-backend 2>/dev/null || echo "Could not get PM2 info"
              echo "ðŸ“‹ PM2 Logs (last 50 lines):"
              pm2 logs website-backend --lines 50 --nostream 2>/dev/null || true
              exit 1
            else
              echo "âŒ PM2 process 'website-backend' not found!"
              exit 1
            fi

            # Check if port is listening
            echo "ðŸ” Checking port 4000..."
            if command -v ss &> /dev/null; then
              PORT_CHECK=$(ss -tlnp | grep :4000 || echo "")
              if [ -n "$PORT_CHECK" ]; then
                echo "âœ… Port 4000 is listening"
                echo "$PORT_CHECK"
              else
                echo "âš ï¸  Port 4000 is NOT listening!"
                echo "Checking all listening ports..."
                ss -tlnp | grep LISTEN | head -10
              fi
            fi

            # Check process
            echo "ðŸ” Checking Node.js processes..."
            ps aux | grep -E "node|tsx" | grep -v grep | head -5

            echo "âœ… Pre-check complete, proceeding to health check..."

      - name: Health check with exponential backoff
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set +e

            echo "ðŸ¥ Starting health check..."
            max_attempts=6
            attempt=1
            backoff=3

            while [ $attempt -le $max_attempts ]; do
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "Attempt $attempt/$max_attempts (waiting ${backoff}s before check)..."
              sleep $backoff
              
              # Check PM2 status first (without jq)
              PM2_LIST=$(pm2 list 2>/dev/null)
              if echo "$PM2_LIST" | grep -q "website-backend.*online"; then
                PM2_STATUS="online"
              else
                PM2_STATUS=$(echo "$PM2_LIST" | grep "website-backend" | awk '{print $10}' 2>/dev/null || echo "unknown")
              fi
              echo "PM2 Status: $PM2_STATUS"
              
              # Try health check
              echo "Testing http://localhost:4000/health..."
              HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" --max-time 10 \
                http://localhost:4000/health 2>&1)
              CURL_EXIT=$?
              
              if [ $CURL_EXIT -ne 0 ]; then
                echo "âŒ curl failed with exit code: $CURL_EXIT"
                echo "curl error output:"
                cat /tmp/health_response.txt 2>/dev/null || echo "No response captured"
              else
                echo "HTTP Code: $HTTP_CODE"
                
                if [ "$HTTP_CODE" = "200" ]; then
                  HEALTH_BODY=$(cat /tmp/health_response.txt 2>/dev/null)
                  echo "Response body: $HEALTH_BODY"
                  
                  if echo "$HEALTH_BODY" | grep -q -E '"status".*"ok"|"status":\s*"ok"'; then
                    echo ""
                    echo "âœ…âœ…âœ… Backend health check PASSED (HTTP 200) âœ…âœ…âœ…"
                    echo "Response: $HEALTH_BODY"
                    rm -f /tmp/health_response.txt
                    exit 0
                  else
                    echo "âš ï¸  HTTP 200 but response doesn't contain 'ok' status"
                  fi
                elif [ "$HTTP_CODE" = "000" ]; then
                  echo "âŒ Connection failed (HTTP 000) - server might not be responding"
                else
                  echo "âš ï¸  Unexpected HTTP code: $HTTP_CODE"
                  HEALTH_BODY=$(cat /tmp/health_response.txt 2>/dev/null)
                  echo "Response: $HEALTH_BODY"
                fi
              fi
              
              # Show more debug info on last attempt
              if [ $attempt -eq $max_attempts ]; then
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âŒ Health check failed after $max_attempts attempts"
                echo ""
                echo "ðŸ“‹ PM2 Status:"
                pm2 list
                echo ""
                echo "ðŸ“‹ PM2 Info:"
                pm2 info website-backend 2>/dev/null || echo "Could not get PM2 info"
                echo ""
                echo "ðŸ“‹ PM2 Logs (last 50 lines):"
                pm2 logs website-backend --lines 50 --nostream 2>/dev/null || true
                echo ""
                echo "ðŸ“‹ Port 4000 status:"
                ss -tlnp | grep :4000 || echo "Port 4000 not listening"
                echo ""
                echo "ðŸ“‹ Node.js processes:"
                ps aux | grep -E "node|tsx" | grep -v grep
                echo ""
                echo "ðŸ“‹ .env file (MONGODB_URI check):"
                if [ -f "/root/backend/.env" ]; then
                  grep "^MONGODB_URI=" /root/backend/.env | sed 's/\(mongodb[^:]*:\/\/[^:]*:\)[^@]*\(@.*\)/\1***\2/' || echo "MONGODB_URI not found"
                else
                  echo ".env file not found!"
                fi
              fi
              
              attempt=$((attempt + 1))
              backoff=$((backoff * 2))
            done

            rm -f /tmp/health_response.txt
            exit 1

      - name: Final verification and cleanup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            echo "âœ… Final verification..."
            echo "ðŸ“Š PM2 Status:"
            pm2 status
            echo ""
            echo "ðŸ“Š Backend Info:"
            pm2 info website-backend 2>/dev/null || echo "âš ï¸  Could not get PM2 info"
            echo ""
            echo "ðŸ§¹ Cleaning old logs..."
            cd /root/backend
            if [ -d "logs" ]; then
              find logs -name "*.log" -type f -size +10M -exec truncate -s 5M {} \; 2>/dev/null || true
            fi
            echo "âœ… Cleanup complete"

      - name: Deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Frontend build completed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Backend build completed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Files deployed to VPS (compressed transfer)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… .env file updated with merge strategy" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… PM2 process restarted" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Nginx reloaded" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Health check passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Deployment Time:** $(date)" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi
