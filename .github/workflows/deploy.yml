name: Deploy Fullstack App to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      deploy_type:
        description: "Deploy mode"
        required: true
        default: "full"
        type: choice
        options:
          - full
          - simple

# Hanya satu deploy aktif; push baru membatalkan yang sedang berjalan
concurrency:
  group: deploy-vps
  cancel-in-progress: true

jobs:
  # ============================
  # ðŸ—ï¸ BUILD STAGE
  # ============================
  build:
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_type != 'simple'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      frontend-build: ${{ steps.build-frontend.outputs.cache-key }}
      backend-build: ${{ steps.build-backend.outputs.cache-key }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js with enhanced caching
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        id: cache-deps
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: npm ci --legacy-peer-deps
        env:
          CI: true

      # Build frontend and backend in parallel using matrix strategy
      - name: Build frontend
        id: build-frontend
        run: |
          echo "ðŸ”· Building React app..."

          # Load .env file if exists, or use secrets/environment
          if [ -f ".env" ]; then
            echo "ðŸ“„ Loading REACT_APP_API_URL from .env file..."
            export REACT_APP_API_URL=$(grep "^REACT_APP_API_URL=" .env | cut -d'=' -f2- | sed 's/^"//;s/"$//' | tr -d '\r\n' || echo "")
            echo "âœ… Loaded from .env: REACT_APP_API_URL=$REACT_APP_API_URL"
          fi

          # Fallback to GitHub Secrets or default
          if [ -z "$REACT_APP_API_URL" ]; then
            REACT_APP_API_URL="${{ secrets.REACT_APP_API_URL }}"
            if [ -z "$REACT_APP_API_URL" ]; then
              REACT_APP_API_URL="https://rickychen930.cloud"
            fi
            export REACT_APP_API_URL
            echo "âœ… Using fallback: REACT_APP_API_URL=$REACT_APP_API_URL"
          fi

          # Verify the value
          echo "ðŸ” Final REACT_APP_API_URL=$REACT_APP_API_URL"

          # Build with the environment variable
          REACT_APP_API_URL="$REACT_APP_API_URL" npm run build

          if [ ! -d "build" ] || [ -z "$(ls -A build)" ]; then
            echo "âŒ Frontend build failed or is empty"
            exit 1
          fi

          # Verify REACT_APP_API_URL is embedded in build (check for the URL in JS files)
          if [ -n "$REACT_APP_API_URL" ] && grep -rqF "$REACT_APP_API_URL" build/static/js/*.js 2>/dev/null; then
            echo "âœ… Verified: API URL is embedded in build"
          else
            echo "âš ï¸  Warning: API URL might not be embedded in build"
          fi

          echo "âœ… Frontend build verified ($(du -sh build | cut -f1))"
          echo "cache-key=frontend-${{ github.sha }}" >> $GITHUB_OUTPUT
        env:
          # This will be overridden by .env file or script logic above
          REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL || 'https://rickychen930.cloud' }}

      - name: Build backend
        id: build-backend
        run: |
          echo "ðŸ”¶ Building backend..."
          npm run backend:build
          if [ ! -d "backend/dist" ] || [ ! -f "backend/dist/main.js" ]; then
            echo "âŒ Backend build failed"
            exit 1
          fi
          echo "âœ… Backend build verified ($(du -sh backend/dist | cut -f1))"
          echo "cache-key=backend-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Prepare deployment artifacts
        run: |
          echo "ðŸ“¦ Creating deployment packages..."
          # Backend: wajib + .env jika ada
          tar -czf backend-deploy.tar.gz \
            backend/dist \
            backend/ecosystem.config.js \
            package.json \
            package-lock.json \
            scripts/fix-backend-on-server.sh
          [ -f .env ] && tar -rzf backend-deploy.tar.gz .env || true

          # Frontend
          tar -czf frontend-deploy.tar.gz build

          # Nginx config
          tar -czf nginx-deploy.tar.gz config/nginx.conf

          echo "âœ… Artifacts created"
          ls -lh *.tar.gz

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts
          path: |
            backend-deploy.tar.gz
            frontend-deploy.tar.gz
            nginx-deploy.tar.gz
          retention-days: 1

  # ============================
  # ðŸš€ DEPLOY STAGE
  # ============================
  deploy:
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_type != 'simple'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    needs: build

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts

      - name: Deploy to VPS (Backend + Frontend + Config)
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          source: "*.tar.gz"
          target: "/tmp/deploy"

      - name: Extract and deploy all services
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "ðŸ“¦ Extracting deployment packages..."

            mkdir -p /root/backend/{logs,dist} /var/www/website-ts /tmp/deploy
            cd /tmp/deploy

            # Backend: extract ke /tmp/deploy, lalu sync ke /root/backend
            if [ -f "backend-deploy.tar.gz" ]; then
              echo "ðŸ”¶ Extracting backend..."
              tar -xzf backend-deploy.tar.gz
              # Sync ke /root/backend
              [ -d "backend/dist" ] && rm -rf /root/backend/dist && cp -r backend/dist /root/backend/
              [ -f "backend/ecosystem.config.js" ] && cp backend/ecosystem.config.js /root/backend/
              [ -f "package.json" ] && cp package.json /root/backend/
              [ -f "package-lock.json" ] && cp package-lock.json /root/backend/
              if [ -f "scripts/fix-backend-on-server.sh" ]; then
                cp scripts/fix-backend-on-server.sh /root/backend/
              elif [ -f "fix-backend-on-server.sh" ]; then
                cp fix-backend-on-server.sh /root/backend/
              fi
              [ -f ".env" ] && cp .env .env.new
            fi

            # Frontend
            if [ -f "frontend-deploy.tar.gz" ]; then
              echo "ðŸ”· Extracting frontend..."
              rm -rf /var/www/website-ts/build
              mkdir -p /var/www/website-ts
              tar -xzf frontend-deploy.tar.gz -C /var/www/website-ts
              sudo chown -R www-data:www-data /var/www/website-ts
              sudo chmod -R 755 /var/www/website-ts
            fi

            # Nginx config
            if [ -f "nginx-deploy.tar.gz" ]; then
              echo "âš™ï¸  Extracting nginx config..."
              tar -xzf nginx-deploy.tar.gz -C /tmp
              NGINX_CONF=$(find /tmp -name "nginx.conf" -type f 2>/dev/null | head -1)
              [ -n "$NGINX_CONF" ] && sudo cp "$NGINX_CONF" /etc/nginx/sites-available/rickychen930.cloud 2>/dev/null || true
            fi

            echo "âœ… Extraction complete"

      - name: Update .env file (effective method)
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "ðŸ” Updating .env file..."
            echo "ðŸ“ IMPORTANT: Backend loads .env from /root/.env (not /root/backend/.env)"
            echo "   See: backend/src/main.ts line 18: path.resolve(__dirname, '../../', '.env')"
            
            # Backend loads from /root/.env (path.resolve from backend/dist -> ../../)
            ENV_FILE="/root/.env"
            ENV_BACKUP="/root/.env.backup.$(date +%Y%m%d_%H%M%S)"
            ENV_NEW="/tmp/deploy/.env.new"
            ENV_BACKEND="/root/backend/.env"  # Keep this as fallback source

            # Backup existing .env files
            if [ -f "$ENV_FILE" ]; then
              cp "$ENV_FILE" "$ENV_BACKUP"
              echo "âœ… Backup created: $(basename $ENV_BACKUP)"
            fi
            
            # Also backup backend .env if exists (as source)
            if [ -f "$ENV_BACKEND" ]; then
              BACKEND_BACKUP="/root/backend/.env.backup.$(date +%Y%m%d_%H%M%S)"
              cp "$ENV_BACKEND" "$BACKEND_BACKUP"
              echo "âœ… Backend .env backed up: $(basename $BACKEND_BACKUP)"
            fi

            # Start with existing .env or create new
            # Prefer /root/.env, fallback to /root/backend/.env for source
            if [ -f "$ENV_FILE" ]; then
              cp "$ENV_FILE" "$ENV_FILE.tmp"
              echo "ðŸ“– Using existing /root/.env as base"
            elif [ -f "$ENV_BACKEND" ]; then
              cp "$ENV_BACKEND" "$ENV_FILE.tmp"
              echo "ðŸ“– Using /root/backend/.env as base (will write to /root/.env)"
            else
              touch "$ENV_FILE.tmp"
              echo "ðŸ“ Creating new /root/.env file"
            fi

            # Update/Add from deployment .env file
            if [ -f "$ENV_NEW" ]; then
              echo "ðŸ“ Applying changes from deployment .env..."
              while IFS= read -r line || [ -n "$line" ]; do
                line=$(echo "$line" | xargs)
                [[ -z "$line" || "$line" =~ ^# ]] && continue
                
                key=$(echo "$line" | cut -d'=' -f1 | xargs)
                value=$(echo "$line" | cut -d'=' -f2- | xargs | sed 's/^"//;s/"$//')
                [[ -z "$key" ]] && continue
                
                if grep -q "^${key}=" "$ENV_FILE.tmp" 2>/dev/null; then
                  sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE.tmp" 2>/dev/null || true
                else
                  echo "${key}=${value}" >> "$ENV_FILE.tmp"
                fi
              done < "$ENV_NEW"
            fi

            # Fast update from GitHub Secrets (priority over file)
            echo "ðŸ”‘ Updating from GitHub Secrets..."
            {
              # Helper function to set env var
              set_env() {
                local key="$1"
                local value="$2"
                if [ -n "$value" ]; then
                  if grep -q "^${key}=" "$ENV_FILE.tmp" 2>/dev/null; then
                    sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE.tmp" 2>/dev/null || true
                  else
                    echo "${key}=${value}" >> "$ENV_FILE.tmp"
                  fi
                  echo "  âœ“ $key"
                fi
              }
              
              # Update from secrets (only if provided)
              # Note: MONGODB_URI is handled separately below with validation and rebuilding
              set_env "PORT" "${{ secrets.BACKEND_PORT }}"
              set_env "NODE_ENV" "${{ secrets.NODE_ENV }}"
              # Skip MONGODB_URI here - handled by dedicated logic below
              set_env "ALLOWED_ORIGINS" "${{ secrets.ALLOWED_ORIGINS }}"
              set_env "SSL_CERT_PATH" "${{ secrets.SSL_CERT_PATH }}"
              set_env "SSL_KEY_PATH" "${{ secrets.SSL_KEY_PATH }}"
            }

            # Ensure defaults exist
            if ! grep -q "^PORT=" "$ENV_FILE.tmp" 2>/dev/null; then
              echo "PORT=4000" >> "$ENV_FILE.tmp"
            fi
            if ! grep -q "^NODE_ENV=" "$ENV_FILE.tmp" 2>/dev/null; then
              echo "NODE_ENV=production" >> "$ENV_FILE.tmp"
            fi

            # Ensure MONGODB_URI exists and has correct format
            # Priority: GitHub Secret > Clean extraction from existing file > Error
            FINAL_MONGODB_URI=""
            
            # Helper function to extract and clean MongoDB URI
            extract_clean_uri() {
              local source_file="$1"
              if [ -f "$source_file" ] && grep -q "^MONGODB_URI=" "$source_file" 2>/dev/null; then
                # Extract URI: get line starting with MONGODB_URI=, take everything after first =, remove quotes, trim whitespace
                local raw_uri=$(grep "^MONGODB_URI=" "$source_file" | head -1 | sed 's/^MONGODB_URI=//' | sed 's/^["'\'']//;s/["'\'']$//' | xargs)
                # Validate: must start with mongodb:// or mongodb+srv://
                if echo "$raw_uri" | grep -qE '^mongodb[+]?srv?://'; then
                  echo "$raw_uri"
                  return 0
                fi
              fi
              return 1
            }
            
            # Helper function to rebuild URI with correct database name
            rebuild_uri() {
              local uri="$1"
              local target_db="${2:-portfolio}"
              
              # Extract credentials (mongodb://user:pass@host or mongodb+srv://user:pass@host)
              local cred_match=$(echo "$uri" | grep -oE 'mongodb[+]?srv?://[^@]+@[^/]+' | head -1)
              
              if [ -n "$cred_match" ]; then
                # Rebuild with correct database and query params
                echo "${cred_match}/${target_db}?retryWrites=true&w=majority&authSource=admin"
                return 0
              fi
              return 1
            }
            
            # Step 1: Try GitHub Secret first (most reliable)
            if [ -n "${{ secrets.MONGODB_URI }}" ]; then
              SECRET_URI="${{ secrets.MONGODB_URI }}"
              # Remove any quotes and trim
              SECRET_URI=$(echo "$SECRET_URI" | sed 's/^["'\'']//;s/["'\'']$//' | xargs)
              
              if echo "$SECRET_URI" | grep -qE '^mongodb[+]?srv?://'; then
                FINAL_MONGODB_URI=$(rebuild_uri "$SECRET_URI" "portfolio")
                if [ -n "$FINAL_MONGODB_URI" ]; then
                  echo "âœ… Using MONGODB_URI from GitHub Secret"
                fi
              fi
            fi
            
            # Step 2: If secret didn't work, try extracting from existing files
            if [ -z "$FINAL_MONGODB_URI" ]; then
              echo "âš ï¸  Secret not available or invalid, trying to extract from existing files..."
              
              # Try /root/.env first
              if [ -f "$ENV_FILE" ]; then
                EXTRACTED=$(extract_clean_uri "$ENV_FILE")
                if [ -n "$EXTRACTED" ]; then
                  FINAL_MONGODB_URI=$(rebuild_uri "$EXTRACTED" "portfolio")
                  if [ -n "$FINAL_MONGODB_URI" ]; then
                    echo "âœ… Extracted and rebuilt URI from /root/.env"
                  fi
                fi
              fi
              
              # Try /root/backend/.env as fallback
              if [ -z "$FINAL_MONGODB_URI" ] && [ -f "$ENV_BACKEND" ]; then
                EXTRACTED=$(extract_clean_uri "$ENV_BACKEND")
                if [ -n "$EXTRACTED" ]; then
                  FINAL_MONGODB_URI=$(rebuild_uri "$EXTRACTED" "portfolio")
                  if [ -n "$FINAL_MONGODB_URI" ]; then
                    echo "âœ… Extracted and rebuilt URI from /root/backend/.env"
                  fi
                fi
              fi
            fi
            
            # Step 3: Validate final URI
            if [ -z "$FINAL_MONGODB_URI" ]; then
              echo "âŒ Could not get valid MONGODB_URI from any source!"
              echo "   Please ensure MONGODB_URI secret is set in GitHub"
              exit 1
            fi
            
            # Validate URI format
            if ! echo "$FINAL_MONGODB_URI" | grep -qE '^mongodb[+]?srv?://[^@]+@[^/]+/[^?]+'; then
              echo "âŒ Invalid MONGODB_URI format: $(echo "$FINAL_MONGODB_URI" | sed 's|//[^:]*:[^@]*@|//***:***@|' | head -c 80)"
              exit 1
            fi
            
            # Extract database name for verification
            DB_NAME_FROM_URI=$(echo "$FINAL_MONGODB_URI" | grep -oE '/[^?]+' | cut -d'/' -f2 | head -1)
            echo "ðŸ“Š Database name: ${DB_NAME_FROM_URI:-unknown}"
            
            # Remove any existing MONGODB_URI from temp file and add the clean one
            grep -v "^MONGODB_URI=" "$ENV_FILE.tmp" > "$ENV_FILE.tmp.clean" 2>/dev/null || true
            mv "$ENV_FILE.tmp.clean" "$ENV_FILE.tmp" 2>/dev/null || true
            echo "MONGODB_URI=$FINAL_MONGODB_URI" >> "$ENV_FILE.tmp"

            # Finalize - write to /root/.env (where backend actually loads from)
            mv "$ENV_FILE.tmp" "$ENV_FILE"
            chmod 600 "$ENV_FILE"

            echo "âœ… .env updated at $ENV_FILE"
            echo "ðŸ“Š Variables: $(grep -v '^#' "$ENV_FILE" | grep -c '=' || echo 0)"
            
            # Final verification with strict validation
            if ! grep -q "^MONGODB_URI=" "$ENV_FILE"; then
              echo "âŒ MONGODB_URI not found in final .env file!"
              exit 1
            fi
            
            # Extract and validate final URI
            FINAL_URI=$(grep "^MONGODB_URI=" "$ENV_FILE" | head -1 | sed 's/^MONGODB_URI=//' | sed 's/^["'\'']//;s/["'\'']$//' | xargs | tr -d '\r\n')
            
            # Check for corruption patterns
            if echo "$FINAL_URI" | grep -qE '(MONGODB_URI=|adminw=|majorityMONGODB_URI|^[^m])'; then
              echo "âŒ .env file appears corrupted! Invalid patterns detected in MONGODB_URI"
              echo "   Preview: $(echo "$FINAL_URI" | head -c 100)"
              exit 1
            fi
            
            # Validate URI format
            if ! echo "$FINAL_URI" | grep -qE '^mongodb[+]?srv?://[^@]+@[^/]+/[^?]+'; then
              echo "âŒ Invalid MONGODB_URI format in final .env!"
              echo "   Preview: $(echo "$FINAL_URI" | sed 's|//[^:]*:[^@]*@|//***:***@|' | head -c 100)"
              exit 1
            fi
            
            FINAL_DB=$(echo "$FINAL_URI" | grep -oE '/[^?]+' | cut -d'/' -f2 | head -1)
            echo "ðŸ“‹ MONGODB_URI (hidden): $(echo "$FINAL_URI" | sed 's|//[^:]*:[^@]*@|//***:***@|' | head -c 80)"
            echo "ðŸ“Š Final database name: ${FINAL_DB:-unknown}"
            
            if [ -z "$FINAL_DB" ]; then
              echo "âš ï¸  Could not extract database name from URI"
            elif [ "$FINAL_DB" = "website-db" ]; then
              echo "âš ï¸  WARNING: Database is still 'website-db', should be 'portfolio'"
              echo "   This might cause issues. Consider updating MONGODB_URI secret."
            elif [ "$FINAL_DB" = "portfolio" ]; then
              echo "âœ… Database name is correct: portfolio"
            fi
            
            # Check for duplicate lines
            URI_COUNT=$(grep -c "^MONGODB_URI=" "$ENV_FILE" || echo "0")
            if [ "$URI_COUNT" -gt 1 ]; then
              echo "âŒ Found $URI_COUNT MONGODB_URI lines (should be 1)! Cleaning..."
              FIRST_URI_LINE=$(grep "^MONGODB_URI=" "$ENV_FILE" | head -1)
              grep -v "^MONGODB_URI=" "$ENV_FILE" > "$ENV_FILE.clean" 2>/dev/null || true
              echo "$FIRST_URI_LINE" >> "$ENV_FILE.clean"
              mv "$ENV_FILE.clean" "$ENV_FILE"
              chmod 600 "$ENV_FILE"
              echo "âœ… Cleaned duplicate lines"
            fi

            # Keep only last 3 backups
            ls -t /root/.env.backup.* 2>/dev/null | tail -n +4 | xargs rm -f 2>/dev/null || true

      - name: Install dependencies and restart services
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e

            echo "âš™ï¸  Configuring services..."
            cd /root/backend

            # Install production dependencies
            echo "ðŸ“¦ Installing production dependencies..."
            npm ci --omit=dev --ignore-scripts --legacy-peer-deps 2>/dev/null || \
            npm install --omit=dev --ignore-scripts --legacy-peer-deps || true

            # Verify PM2 config
            if [ ! -f "ecosystem.config.js" ]; then
              echo "âŒ PM2 ecosystem.config.js not found"
              exit 1
            fi

            # Ensure /root/.env exists (backend loads from here, not /root/backend/.env)
            echo "ðŸ“ Ensuring /root/.env exists (backend load path)..."
            if [ ! -f "/root/.env" ]; then
              echo "âš ï¸  /root/.env not found, creating clean .env file..."
              
              # Helper to extract and rebuild URI
              extract_and_rebuild_uri() {
                local source_file="$1"
                if [ -f "$source_file" ] && grep -q "^MONGODB_URI=" "$source_file" 2>/dev/null; then
                  local raw_uri=$(grep "^MONGODB_URI=" "$source_file" | head -1 | sed 's/^MONGODB_URI=//' | sed 's/^["'\'']//;s/["'\'']$//' | xargs | tr -d '\r\n')
                  if echo "$raw_uri" | grep -qE '^mongodb[+]?srv?://'; then
                    local cred_match=$(echo "$raw_uri" | grep -oE 'mongodb[+]?srv?://[^@]+@[^/]+' | head -1)
                    if [ -n "$cred_match" ]; then
                      echo "${cred_match}/portfolio?retryWrites=true&w=majority&authSource=admin"
                      return 0
                    fi
                  fi
                fi
                return 1
              }
              
              FINAL_URI=""
              
              # Try GitHub Secret first
              if [ -n "${{ secrets.MONGODB_URI }}" ]; then
                SECRET_URI=$(echo "${{ secrets.MONGODB_URI }}" | sed 's/^["'\'']//;s/["'\'']$//' | xargs | tr -d '\r\n')
                if echo "$SECRET_URI" | grep -qE '^mongodb[+]?srv?://'; then
                  CRED_MATCH=$(echo "$SECRET_URI" | grep -oE 'mongodb[+]?srv?://[^@]+@[^/]+' | head -1)
                  if [ -n "$CRED_MATCH" ]; then
                    FINAL_URI="${CRED_MATCH}/portfolio?retryWrites=true&w=majority&authSource=admin"
                    echo "âœ… Using MONGODB_URI from GitHub Secret"
                  fi
                fi
              fi
              
              # Try extracting from /root/backend/.env
              if [ -z "$FINAL_URI" ] && [ -f "/root/backend/.env" ]; then
                EXTRACTED=$(extract_and_rebuild_uri "/root/backend/.env")
                if [ -n "$EXTRACTED" ]; then
                  FINAL_URI="$EXTRACTED"
                  echo "âœ… Extracted URI from /root/backend/.env"
                fi
              fi
              
              if [ -z "$FINAL_URI" ]; then
                echo "âŒ Could not create valid MONGODB_URI!"
                echo "   Please ensure MONGODB_URI secret is set in GitHub"
                exit 1
              fi
              
              # Validate URI before writing
              if ! echo "$FINAL_URI" | grep -qE '^mongodb[+]?srv?://[^@]+@[^/]+/[^?]+'; then
                echo "âŒ Invalid MONGODB_URI format!"
                exit 1
              fi
              
              # Create complete .env file using printf (escape % for printf)
              printf "# Server Configuration\nPORT=4000\nNODE_ENV=production\n\n# Database\n# MongoDB Atlas\nMONGODB_URI=%s\n\n# CORS Configuration (comma-separated)\n# Production:\nALLOWED_ORIGINS=https://rickychen930.cloud,https://www.rickychen930.cloud\n\n# SSL Configuration (for production with Let's Encrypt)\n# These paths are used by nginx, not the Node.js backend\n# Let's Encrypt default paths:\nSSL_CERT_PATH=/etc/letsencrypt/live/rickychen930.cloud/fullchain.pem\nSSL_KEY_PATH=/etc/letsencrypt/live/rickychen930.cloud/privkey.pem\nSSL_CHAIN_PATH=/etc/letsencrypt/live/rickychen930.cloud/chain.pem\n\n# SSL Certificate Domain (for Let's Encrypt)\nSSL_DOMAIN=rickychen930.cloud\nSSL_ALT_DOMAINS=www.rickychen930.cloud\n\n# Frontend API URL (for React app)\n# Production:\nREACT_APP_API_URL=https://rickychen930.cloud\n" "$FINAL_URI" > /root/.env
              chmod 600 /root/.env
              
              DB_NAME=$(echo "$FINAL_URI" | grep -oE '/[^?]+' | cut -d'/' -f2 | head -1)
              echo "âœ… Created /root/.env with database: ${DB_NAME:-portfolio}"
            fi
            
            # Verify .env file with strict validation
            echo "ðŸ” Verifying /root/.env..."
            if [ ! -f "/root/.env" ]; then
              echo "âŒ /root/.env still not found after creation attempt!"
              exit 1
            fi
            
            echo "âœ… /root/.env exists"
            
            # Verify MONGODB_URI exists and is valid
            if ! grep -q "^MONGODB_URI=" /root/.env; then
              echo "âŒ MONGODB_URI not found in .env!"
              exit 1
            fi
            
            # Extract and validate URI
            ENV_URI=$(grep "^MONGODB_URI=" /root/.env | head -1 | sed 's/^MONGODB_URI=//' | sed 's/^["'\'']//;s/["'\'']$//' | xargs | tr -d '\r\n')
            
            # Check for common corruption patterns
            if echo "$ENV_URI" | grep -qE '(MONGODB_URI=|adminw=|majorityMONGODB_URI)'; then
              echo "âŒ .env file appears corrupted! Found invalid patterns in MONGODB_URI"
              echo "   URI preview: $(echo "$ENV_URI" | head -c 100)"
              exit 1
            fi
            
            # Validate URI format
            if ! echo "$ENV_URI" | grep -qE '^mongodb[+]?srv?://[^@]+@[^/]+/[^?]+'; then
              echo "âŒ Invalid MONGODB_URI format in .env!"
              echo "   URI preview: $(echo "$ENV_URI" | sed 's|//[^:]*:[^@]*@|//***:***@|' | head -c 100)"
              exit 1
            fi
            
            # Extract database name
            DB_NAME=$(echo "$ENV_URI" | grep -oE '/[^?]+' | cut -d'/' -f2 | head -1)
            if [ -z "$DB_NAME" ]; then
              echo "âš ï¸  Could not extract database name from URI"
            else
              echo "âœ… MONGODB_URI is valid"
              echo "ðŸ“Š Database name: $DB_NAME"
              
              # Warn if database is not 'portfolio'
              if [ "$DB_NAME" != "portfolio" ]; then
                echo "âš ï¸  Database name is '$DB_NAME', expected 'portfolio'"
              fi
            fi
            
            # Check for duplicate MONGODB_URI lines (corruption indicator)
            URI_COUNT=$(grep -c "^MONGODB_URI=" /root/.env || echo "0")
            if [ "$URI_COUNT" -gt 1 ]; then
              echo "âŒ Found $URI_COUNT MONGODB_URI lines in .env (should be 1)!"
              echo "   This indicates file corruption. Cleaning..."
              # Keep only the first valid MONGODB_URI line
              FIRST_URI_LINE=$(grep "^MONGODB_URI=" /root/.env | head -1)
              grep -v "^MONGODB_URI=" /root/.env > /root/.env.clean 2>/dev/null || true
              echo "$FIRST_URI_LINE" >> /root/.env.clean
              mv /root/.env.clean /root/.env
              chmod 600 /root/.env
              echo "âœ… Cleaned duplicate MONGODB_URI lines"
            fi
            
            # Verify dist exists
            if [ ! -f "dist/main.js" ]; then
              echo "âŒ dist/main.js not found! Backend cannot start."
              exit 1
            fi
            echo "âœ… dist/main.js exists"
            
            # Stop and delete PM2 process
            echo "ðŸ›‘ Stopping existing PM2 process..."
            pm2 stop website-backend 2>/dev/null || true
            pm2 delete website-backend 2>/dev/null || true
            sleep 2
            
            # Start PM2
            echo "ðŸš€ Starting PM2 with fresh environment..."
            pm2 start ecosystem.config.js --env production --update-env
            pm2 save
            
            # Wait for startup
            echo "â³ Waiting for backend to start (10s)..."
            sleep 10
            
            # Verify PM2 is running
            echo "ðŸ” Verifying PM2 status..."
            pm2 list
            PM2_STATUS=$(pm2 jlist | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "unknown")
            if [ "$PM2_STATUS" != "online" ]; then
              echo "âŒ PM2 process is not online! Status: $PM2_STATUS"
              echo "ðŸ“‹ PM2 logs (last 50 lines):"
              pm2 logs website-backend --lines 50 --nostream 2>/dev/null || true
              exit 1
            fi
            echo "âœ… PM2 process is online"
            
            # Test health endpoint
            echo "ðŸ¥ Testing health endpoint..."
            for i in {1..5}; do
              sleep 2
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:4000/health 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Health check passed (HTTP 200)"
                break
              else
                echo "âš ï¸  Health check attempt $i/5: HTTP $HTTP_CODE"
                if [ $i -eq 5 ]; then
                  echo "âŒ Health check failed after 5 attempts"
                  echo "ðŸ“‹ PM2 logs (last 30 lines):"
                  pm2 logs website-backend --lines 30 --nostream 2>/dev/null || true
                  exit 1
                fi
              fi
            done

            # Final verification before nginx restart
            echo "ðŸ” Final verification before nginx restart..."
            for i in {1..3}; do
              sleep 2
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:4000/health 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Backend is ready (HTTP 200)"
                break
              else
                echo "âš ï¸  Backend not ready yet (HTTP $HTTP_CODE), attempt $i/3"
                if [ $i -eq 3 ]; then
                  echo "âŒ Backend not responding after 3 attempts"
                  echo "ðŸ“‹ PM2 status:"
                  pm2 list
                  echo "ðŸ“‹ Recent logs:"
                  pm2 logs website-backend --lines 20 --nostream 2>/dev/null || true
                  exit 1
                fi
              fi
            done

            # Restart nginx
            echo "ðŸ”„ Restarting nginx..."
            sudo nginx -t 2>/dev/null && sudo systemctl reload nginx 2>/dev/null || \
            sudo systemctl restart nginx 2>/dev/null || true

            echo "âœ… Services restarted"

            # Cleanup deployment temp files
            rm -rf /tmp/deploy

      - name: Health check with exponential backoff
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set +e

            echo "ðŸ¥ Starting health check..."
            max_attempts=6
            attempt=1
            backoff=2

            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts (waiting ${backoff}s)..."
              sleep $backoff
              
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 \
                http://localhost:4000/health 2>/dev/null || echo "000")
              
              if [ "$HTTP_CODE" = "200" ]; then
                HEALTH_BODY=$(curl -s --max-time 5 http://localhost:4000/health 2>/dev/null)
                if echo "$HEALTH_BODY" | grep -q -E '"status".*"ok"|"status":\s*"ok"'; then
                  echo "âœ… Backend health check passed (HTTP 200)"
                  echo "Response: $(echo "$HEALTH_BODY" | head -1)"
                  exit 0
                fi
              fi
              
              echo "HTTP Code: $HTTP_CODE"
              attempt=$((attempt + 1))
              backoff=$((backoff * 2))
            done

            echo "âŒ Health check failed after $max_attempts attempts"
            echo "ðŸ“‹ PM2 Status:"
            pm2 list
            echo "ðŸ“‹ PM2 Info:"
            pm2 info website-backend 2>/dev/null || true
            echo ""
            echo "ðŸ“‹ Checking /root/.env:"
            if [ -f "/root/.env" ]; then
              echo "âœ… /root/.env exists"
              echo "   MONGODB_URI: $(grep '^MONGODB_URI=' /root/.env | sed 's|//[^:]*:[^@]*@|//***:***@|' | head -c 80)"
            else
              echo "âŒ /root/.env NOT FOUND!"
            fi
            echo ""
            echo "ðŸ“‹ PM2 Logs (last 50 lines):"
            pm2 logs website-backend --lines 50 --nostream 2>/dev/null || true
            echo ""
            echo "ðŸ“‹ Testing direct connection:"
            curl -v http://localhost:4000/health 2>&1 | head -20 || true
            exit 1

      - name: Final verification and cleanup
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            echo "âœ… Final verification..."
            echo "ðŸ“Š PM2 Status:"
            pm2 status
            echo ""
            echo "ðŸ“Š Backend Info:"
            pm2 info website-backend 2>/dev/null || echo "âš ï¸  Could not get PM2 info"
            echo ""
            echo "ðŸ§¹ Cleaning old logs..."
            cd /root/backend
            if [ -d "logs" ]; then
              find logs -name "*.log" -type f -size +10M -exec truncate -s 5M {} \; 2>/dev/null || true
            fi
            echo "âœ… Cleanup complete"

      - name: Deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Frontend build completed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Backend build completed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Files deployed to VPS (compressed transfer)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… .env file updated with merge strategy" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… PM2 process restarted" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Nginx reloaded" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Health check passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Deployment Time:** $(date)" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================
  # ðŸš€ DEPLOY SIMPLE (git pull on server)
  # ============================
  deploy-simple:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_type == 'simple'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Deploy via SSH (git pull + build + restart)
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set -e
            echo "ðŸ“¦ Simple deploy: git pull + build + restart..."
            cd /var/www/website-ts
            git pull
            npm install
            npm run build
            
            # Backend
            cd /root/backend
            (npm ci --omit=dev --ignore-scripts --legacy-peer-deps 2>/dev/null || npm install --omit=dev --ignore-scripts --legacy-peer-deps || true)
            
            # Ensure /root/.env exists (backend loads from here)
            if [ ! -f "/root/.env" ] && [ -f "/root/backend/.env" ]; then
              echo "ðŸ“ Creating /root/.env from /root/backend/.env..."
              cp /root/backend/.env /root/.env
            fi
            
            # Restart with update-env flag
            pm2 restart website-backend --update-env 2>/dev/null || {
              pm2 stop website-backend 2>/dev/null || true
              pm2 delete website-backend 2>/dev/null || true
              pm2 start ecosystem.config.js --env production --update-env
              pm2 save
            }
            
            sudo systemctl restart nginx
            echo "âœ… Simple deploy complete"

      - name: Health check (timeout 300s)
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER_SSH_KEY }}
          port: 22
          script: |
            set +e
            echo "ðŸ¥ Health check: https://rickychen930.cloud/health (timeout 300s)..."
            max_attempts=10
            attempt=1
            backoff=5
            total_wait=0
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts (waiting ${backoff}s, total ~${total_wait}s)..."
              sleep $backoff
              total_wait=$((total_wait + backoff))
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://localhost:4000/health 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                HEALTH_BODY=$(curl -s --max-time 10 http://localhost:4000/health 2>/dev/null)
                if echo "$HEALTH_BODY" | grep -qE '"status".*"ok"|"status":\s*"ok"'; then
                  echo "âœ… Health check passed (HTTP 200)"
                  exit 0
                fi
              fi
              echo "HTTP $HTTP_CODE"
              attempt=$((attempt + 1))
              backoff=$((backoff + 5))
            done
            echo "âŒ Health check failed after ~300s"
            pm2 list
            exit 1

      - name: Deployment summary (simple)
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary (Simple)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… Simple Deploy Successful" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Git pull + build on server" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… PM2 + nginx restarted" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Health check passed" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Simple Deploy Failed" >> $GITHUB_STEP_SUMMARY
            echo "Check logs above." >> $GITHUB_STEP_SUMMARY
          fi
